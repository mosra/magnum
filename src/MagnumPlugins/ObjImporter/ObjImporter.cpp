/*
    This file is part of Magnum.

    Copyright © 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
              Vladimír Vondruš <mosra@centrum.cz>

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

#include "ObjImporter.h"

#include <fstream>
#include <limits>
#include <sstream>
#include <cstdlib>
#include <unordered_map>
#include <Corrade/Containers/ArrayView.h>
#include <Corrade/Utility/String.h>
#include <Corrade/Utility/Directory.h>

#include "Magnum/Mesh.h"
#include "Magnum/MeshTools/CombineIndexedArrays.h"
#include "Magnum/MeshTools/Duplicate.h"
#include "Magnum/Math/Vector3.h"
#include "Magnum/Math/Color.h"
#include "Magnum/Trade/MeshData3D.h"
#include "Magnum/Trade/MeshObjectData3D.h"
#include "Magnum/Trade/ImageData.h"
#include "Magnum/Trade/PhongMaterialData.h"

#include "MagnumPlugins/TgaImporter/TgaImporter.h"

using namespace Corrade::Containers;

namespace Magnum { namespace Trade {


/* Not using PhongMaterialData, since we may want to set color and texture to
 * later decide which flags we set. We do not know whether we have a texture
 * or color beforehand. */
struct ObjMaterial {
    std::string name;
    Color3 ambient;
    Color3 diffuse;
    Color3 specular;
    Float specularity;
    Int ambientTexture = -1;
    Int diffuseTexture = -1;
    Int specularTexture = -1;
};

struct ObjObject;
struct ObjGroup;
struct ObjMesh;

struct ObjMeshData {
    ObjGroup& group;
    Int materialId; /* From 'usemtl' keyword */

    ObjMesh* poInts = nullptr;
    ObjMesh* lines = nullptr;
    ObjMesh* faces = nullptr;

    explicit ObjMeshData(ObjGroup& g, Int matId): group(g), materialId(matId) {}
};

struct ObjGroup {
    ObjObject& object;
    std::string name; /* From 'g' keyword */

    std::vector<std::unique_ptr<ObjMeshData>> meshes;
    std::unordered_map<Int, Int> meshPerMaterial;

    explicit ObjGroup(ObjObject& o): object(o) {}

    /* Create or get mesh for given material id */
    ObjMeshData& meshDataForMaterial(Int materialId) {
        if(meshPerMaterial.find(materialId) != meshPerMaterial.end()) {
            return *meshes[meshPerMaterial[materialId]];
        } else {
            meshPerMaterial[materialId] = meshes.size();
            meshes.emplace_back(new ObjMeshData{*this, materialId});
            ObjMeshData& mesh = *meshes.back();
            return mesh;
        }
    }
};

struct ObjObject {
    std::string name; /* From 'o' keyword */
    std::vector<std::unique_ptr<ObjGroup>> groups;

    ObjObject(): name{""} {}
    ObjObject(ArrayView<const char> name): name{name.data(), name.size()} {}
};

/* An Intermediate object representing a mesh and it's properties as well as
 * where to find the data associated to it */
struct ObjMesh {
    ObjMeshData& data; /* Parent object containing data shared meshes for different primitives */
    MeshPrimitive primitive;

    /* Sections of the file belonging to this mesh */
    std::vector<ArrayView<const char>> sections;

    Int minPrimitives = 0; /* For smarter vector memory allocation later */

    explicit ObjMesh(ObjMeshData& d, MeshPrimitive p): data(d), primitive(p) {}

    std::string name() {
        std::string name = data.group.object.name;

        if(!data.group.name.empty()) {
            name += ":" + data.group.name;
        }

        if(data.materialId != -1) {
            name += "$" + std::to_string(data.materialId);
        }

        const Int numPrimitiveTypes =
            ((data.poInts) ? 1 : 0)
            + ((data.lines) ? 1 : 0)
            + ((data.faces) ? 1 : 0);
        if(numPrimitiveTypes > 1) {
            std::ostringstream out;
            Debug(&out) << primitive;
            name += "%" + out.str();
        }

        return name;
    }
};


/* The state of the imported generated by openData() */
struct ImporterState {
    Containers::Array<char> in;
    std::string fileRoot;

    std::vector<ObjMaterial> materials;
    std::unordered_map<std::string, Int> materialIds;

    std::vector<std::string> textures;
    std::unordered_map<std::string, Int> textureIds;

    std::vector<std::unique_ptr<ObjObject>> objects;

    std::vector<std::unique_ptr<ObjMesh>> meshes;
    std::unordered_map<std::string, Int> meshIds;

    std::vector<std::string> meshlessObjects;
    std::unordered_map<std::string, Int> meshlessObjectIds;

    std::vector<Vector3> positions;
    std::vector<Vector2> texCoords;
    std::vector<Vector3> normals;
};

namespace {

/* Returns the given string parsed as Int */
Int strToInt(const ArrayView<const char> str) {
    char* err;
    const Int i = Int(strtol(str.data(), &err, 10));
    if(err == nullptr) {
        Error() << "Trade::ObjImporter::mesh3D(): error while converting numeric data";
        return 0;
    }

    return i;
}

/* Returns the given string parsed as Float */
Float strToFloat(const ArrayView<const char> str) {
    char* err;
    const Float f = strtof(str.data(), &err);
    if(err == nullptr) {
        Error() << "Trade::ObjImporter::mesh3D(): error while converting numeric data";
        return 0;
    }

    return f;
}

/*
 * Returns the index of the next occurrence of `c` or -1, if it could not be found.
 *
 * @param termByNewline if `true`, the search will terminate at '\n' and return -1.
 * @param termByWhitespace if `true`, the search will terminate at ' ' and return -1.
 */
Int findNext(const ArrayView<const char> pos, char c, bool termByNewline=false, bool termByWhitespace=false) {
    const Int size = pos.size();
    for(Int i = 0; i < size; ++i) {
        if(pos[i] == c) {
            return i;
        }

        if((pos[i] == '\n' && termByNewline) || (pos[i] == ' ' && termByWhitespace)) {
            return -1;
        }
    }
    return -1;
}

/*
 * Return suffix beginning at next non-whitespace character
 * @param newlineIsWhitespace if `true`, '\n' and '\r' are skipped also
 */
ArrayView<const char> skipWhitespaces(const ArrayView<const char> pos, bool newlineIsWhitespace=true) {
    const Int size = pos.size();
    for(Int i = 0; i < size; ++i) {
        const char c = pos[i];
        if(c != ' ' && c != '\t' && c != '\0' && (!newlineIsWhitespace || (c != '\n'  && c != '\r'))) {
            return pos.suffix(i);
        }
    }
    return {};
}

/* Returns suffix after the next '\n' or the given ArrayView if no newline could be found */
ArrayView<const char> ignoreLine(const ArrayView<const char> pos) {
    return pos.suffix(findNext(pos, '\n') + 1);
}

/* Returns a prefix until the next '\n' and the suffix after the newline. */
std::pair<ArrayView<const char>, ArrayView<const char>> nextLine(const ArrayView<const char>& pos) {
    Int i = Math::min(findNext(pos, '\n'), findNext(pos, '\r'));
    if(i == -1)         {
        i = pos.size();
        return {pos.prefix(i), pos.suffix(i)};
    }
    return {pos.prefix(i), pos.suffix(i+1)};
}

/* Returns true if the next non-whitespace character is a newline character */
bool atEndOfLine(const ArrayView<const char> pos) {
    Int i = 0;
    while(pos[i] == ' ') ++i;

    return (pos[i] == '\n' || pos[i] == '\r');
}

/* Returns the prefix until the next ' ' character and the suffix starting with it */
std::pair<ArrayView<const char>, ArrayView<const char>> nextWord(const ArrayView<const char> pos) {
    Int i = 0;
    const Int size = pos.size();
    for(; i < size; ++i) {
        if(pos[i] == ' ' || pos[i] == '\r' || pos[i] == '\n' || pos[i] == '\0') {
            break;
        }
    }
    return {pos.prefix(i), pos.suffix(i)};
}

/* Parse indices for a line, e.g. "1/2" */
std::pair<std::array<Int, 2>, ArrayView<const char>> parseLine(const ArrayView<const char> pos) {
    std::array<Int, 2> indices{0, 0};
    ArrayView<const char> endpos{};

    Int i = findNext(pos, '/', true, true);
    if(i == -1) {
        /* v1 v2 rather than v1/t1 v2/t2 or v1/ v2/ */
        ArrayView<const char> word;
        std::tie(word, endpos) = nextWord(pos);
        indices[0] = strToInt(word);
        return {indices, endpos};
    }

    indices[0] = strToInt(pos.prefix(i));
    endpos = pos.suffix(i+1);

    i = findNext(endpos, ' ', true, true); /* Texture coordinates are not terminated by '/', but ' ' or newline */
    if(i == -1)
        i = findNext(endpos, '\r', true, true);
    if(i == -1)
        i = findNext(endpos, '\n', true, true);

    if(i != -1) { /* There may not be a texCoord! Eg. "1/" */
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[1] = strToInt(prefix);
            endpos = endpos.suffix(i);
        }
    }

    return {indices, endpos};
}

/* Parse a "v/n/t" string to indices for a face */
std::pair<std::array<Int, 3>, ArrayView<const char>> parseVertex(const ArrayView<const char> pos) {
    std::array<Int, 3> indices{0, 0, 0};
    ArrayView<const char> endpos{};

    Int i = findNext(pos, '/', true, true);
    if(i == -1) {
        /* v1 v2 rather than v1/t1 v2/t2 or v1/ v2/ */
        ArrayView<const char> word;
        std::tie(word, endpos) = nextWord(pos);
        indices[0] = strToInt(word);
        return {indices, endpos};
    }

    indices[0] = strToInt(pos.prefix(i));
    endpos = pos.suffix(i+1);

    i = findNext(endpos, '/', true, true);
    if(i != -1) { /* There may not be a normal! Eg. "1//2", in which case the indices of the / are 1 apart */
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[1] = strToInt(prefix);
        }
        endpos = endpos.suffix(i+1);
    }

    i = findNext(endpos, ' ', true, true); /* Texture coordinates are not terminated by '/', but ' ' or newline */
    if(i == -1)
        i = findNext(endpos, '\r', true, true);
    if(i == -1)
        i = findNext(endpos, '\n', true, true);

    if(i != -1) { /* There may not be a texCoord! Eg. "1//" */
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[2] = strToInt(prefix);
            endpos = endpos.suffix(i);
        }
    }

    return {indices, endpos};
}

template<UnsignedInt dimensions> Math::Vector<dimensions, Float> parseVector(ArrayView<const char>& pos) {
    ArrayView<const char> word;
    Math::Vector<dimensions, Float> v;

    for(Int i = 0; i < Int(dimensions); ++i) {
        std::tie(word, pos) = nextWord(skipWhitespaces(pos));
        v[i] = strToFloat(word);
    }

    return v;
}

template<class T> std::vector<T> reindex(const std::vector<UnsignedInt>& indices, const std::vector<T>& data) {
    /* Check that indices are in range */
    for(UnsignedInt i: indices) if(i >= data.size()) {
        Error() << "Trade::ObjImporter::mesh3D(): index out of range";
        return {};
    }

    return MeshTools::duplicate(indices, data);
}

}

ObjImporter::ObjImporter() = default;

ObjImporter::ObjImporter(PluginManager::AbstractManager& manager, const std::string& plugin): AbstractImporter{manager, plugin} {}

ObjImporter::~ObjImporter() = default;

auto ObjImporter::doFeatures() const -> Features { return Feature::OpenData; }

void ObjImporter::doClose() { _state->in = nullptr; }

bool ObjImporter::doIsOpened() const { return _state->in; }

void ObjImporter::doOpenFile(const std::string& filename) {
    _state->fileRoot = Utility::Directory::path(filename);
    AbstractImporter::doOpenFile(filename);
}

void ObjImporter::doOpenData(Containers::ArrayView<const char> data) {
    _state->in = Containers::Array<char>{data.size()};
    std::copy(data.begin(), data.end(), _state->in.begin());
    _state.reset(new ImporterState);
    parse();
}

void ObjImporter::parse() {
    ArrayView<const char> line = _state->in; /* Points to beginning of current line */
    ArrayView<const char> pos = _state->in;  /* Points to current character in line */

    ObjObject* object = nullptr;
    ObjGroup* group = nullptr;
    ObjMeshData* meshData = nullptr;

    ArrayView<const char> section{nullptr};
    Int minSectionPrimitives = 0;
    char sectionPrimitive = '?';

    /* Set index 0 of data to default value */
    _state->positions.emplace_back();
    _state->normals.emplace_back(); // TODO Default normal?
    _state->texCoords.emplace_back();

    /* Create 'object' if not created by 'o' keyword */
    auto ensureObject = [&]{
        if(object == nullptr) {
            // TODO: C++ 17
            _state->objects.emplace_back(new ObjObject);
            object = _state->objects.back().get();
        }
    };

    /* Create 'group' if not created by 'g' keyword */
    auto ensureGroup = [&]{
        if(group == nullptr) {
            ensureObject();

            // TODO: C++ 17
            object->groups.emplace_back(new ObjGroup{*object});
            group = object->groups.back().get();
        }
    };

    /* Create 'meshData' if not created by 'usemtl' keyword */
    auto ensureMeshData = [&](){
        if(meshData == nullptr) {
            ensureGroup();
            meshData = &group->meshDataForMaterial(-1);
        }
    };

    /* Close a section and add it to the current meshData */
    auto finishSection = [&]{
        if(section.data() == nullptr) {
            /* No open section */
            return;
        }

        ensureMeshData();

        ObjMesh* mesh;
        if(sectionPrimitive == 'p') {
            if(!meshData->poInts) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Points});
                meshData->poInts = _state->meshes.back().get();
            }
            mesh = meshData->poInts;
        } else if(sectionPrimitive == 'l') {
            if(!meshData->lines) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Lines});
                meshData->lines = _state->meshes.back().get();
            }
            mesh = meshData->lines;
        } else if(sectionPrimitive == 'f') {
            if(!meshData->faces) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Triangles});
                meshData->faces = _state->meshes.back().get();
            }
            mesh = meshData->faces;
        } else {
            CORRADE_ASSERT_UNREACHABLE();
        }
        if(line.data() == nullptr) {
            /* Usually for the last line */
            mesh->sections.push_back(section);
        } else {
            mesh->sections.emplace_back(section.data(), size_t(line.data()-section.data()));
        }
        mesh->minPrimitives += minSectionPrimitives;

        section = {nullptr};
        minSectionPrimitives = 0;
    };

    auto finishObject = [&]{
        if(object && object->groups.empty()) {
            /* Create dummy mesh for this object so that it gets loaded as ObjectData */
            _state->meshlessObjects.push_back(object->name);
        }
    };

    while(!pos.empty()) {

        /* Comment line */
        if(pos[0] == '#') {
            finishSection();
            line = pos = skipWhitespaces(ignoreLine(pos));
            continue;
        }

        /* Parse the keyword */
        std::string keyword;
        ArrayView<const char> word;
        std::tie(word, pos) = nextWord(pos);
        keyword = std::string(word.data(), word.size());

        pos = skipWhitespaces(pos);
        bool sectionEnd = true;

        /* Vertex position */
        if(keyword == "v") {
            _state->positions.push_back(parseVector<3>(pos));

        /* Texture coordinate */
        } else if(keyword == "vt") {
            _state->texCoords.push_back(parseVector<2>(pos));

        /* Normal */
        } else if(keyword == "vn") {
            _state->normals.push_back(parseVector<3>(pos));

        /* Indices */
        } else if(keyword == "f" || keyword == "l" || keyword == "p") {
            sectionEnd = false;

            if(sectionPrimitive != keyword[0]) {
                /* Create new section, mixed primitives! */
                finishSection();
            }

            if(section.data() == nullptr) {
                /* Create new section */
                section = line;
                sectionPrimitive = keyword[0];
            }

            ++minSectionPrimitives;

        /* Object name */
        } else if(keyword == "o") {
            finishSection();
            finishObject();

            ArrayView<const char> name;
            std::tie(name, pos) = nextWord(pos);

            _state->objects.emplace_back(new ObjObject{name});
            object = _state->objects.back().get();
            group = nullptr;
            meshData = nullptr;

        /* Object group */
        } else if(keyword == "g") {
            //TODO: Handle geometry shared by multiple groups, e.g. g group1 group2
            ensureObject();
            object->groups.emplace_back(new ObjGroup{*object});
            group = object->groups.back().get();

            meshData = nullptr;

            ArrayView<const char> name;
            std::tie(name, pos) = nextWord(pos);
            group->name = std::string{name.data(), name.size()};

        /* Load a material library */
        } else if(keyword == "mtllib") {
            ArrayView<const char> word;
            pos = skipWhitespaces(pos);
            std::tie(word, pos) = nextWord(pos);

            parseMaterialLibrary(word);

        /* Set current material and add a new mesh for it */
        } else if(keyword == "usemtl") {
            ArrayView<const char> word;
            pos = skipWhitespaces(pos);
            std::tie(word, pos) = nextWord(pos);

            const Int materialIndex = _state->materialIds[std::string{word.data(), word.size()}];
            if(meshData == nullptr || materialIndex != meshData->materialId) {
                /* Switching the material here, need to create a new mesh */
                //TODO C++17
                ensureGroup();
                meshData = &group->meshDataForMaterial(materialIndex);
            } // else: usemtl did not result in material switch, no need to create new mesh

        /* Ignore unsupported keywords, error out on unknown keywords */
        } else {
            Warning() << "Trade::ObjImporter::parse(): unknown keyword:" << keyword;
        }

        if(sectionEnd) {
            finishSection();
        }

        /* Ignore the rest of the line */
        line = pos = skipWhitespaces(ignoreLine(pos));
    }

    finishSection();
    finishObject();

    Int i = _state->meshes.size();
    for(auto name : _state->meshlessObjects) {
        _state->meshlessObjectIds[name] = i++;
    }
}

void ObjImporter::parseMaterialLibrary(const ArrayView<const char> libname) {
    std::string filename = _state->fileRoot + std::string(libname.data(), libname.size());

    /* Open file */
    if(!Utility::Directory::fileExists(filename)) {
        Error() << "Trade::AbstractImporter::parseMaterialLibrary(): cannot open file" << filename;
        return;
    }

    Containers::Array<char> contents = Utility::Directory::read(filename);
    ArrayView<const char> pos = contents;  /* Points to current character in line */

    ObjMaterial* mat = nullptr;

    while(!pos.empty()) {

        /* Comment line */
        if(pos[0] == '#') {
            pos = ignoreLine(pos);
            pos = skipWhitespaces(pos);
            continue;
        }

        /* Parse the keyword */
        ArrayView<const char> word;
        std::tie(word, pos) = nextWord(pos);
        std::string keyword{word.data(), word.size()};

        if(keyword.empty()) {
            pos = skipWhitespaces(pos);
            continue;
        }

        pos = skipWhitespaces(pos);

        if(keyword == "newmtl") {
            std::tie(word, pos) = nextWord(pos);

            _state->materials.emplace_back();
            mat = &_state->materials.back();
            mat->name = std::string{word.data(), word.size()};

            _state->materialIds[mat->name] = _state->materials.size()-1;
            continue;
        } else if (mat == nullptr) {
            Error() << "Expected newmtl keyword, got" << keyword;
        }

        /* Ambient color */
        if(keyword == "Ka") {
            ArrayView<const char> word;

            for(Int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->ambient[i] = strToFloat(word);
            }

        /* Diffuse color */
        } else if(keyword == "Kd") {
            ArrayView<const char> word;

            for(Int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->diffuse[i] = strToFloat(word);
            }

        /* Specular color */
        } else if(keyword == "Ks") {
            ArrayView<const char> word;

            for(Int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->specular[i] = strToFloat(word);
            }

        /* Specularity */
        } else if(keyword == "Ns") {
            ArrayView<const char> word;

            std::tie(word, pos) = nextWord(pos);
            const Float f = strToFloat(word);

            mat->specularity = f;
        /* Ambient texture */
        } else if(keyword.substr(0, 4) == "map_") {
            ArrayView<const char> line;
            std::tie(line, pos) = nextLine(pos);
            std::string texture{line.data(), line.size()};

            Int textureId = -1;
            if(_state->textureIds.find(texture) == _state->textureIds.end()) {
                /* new texture, create it */
                Int index = _state->textures.size();
                _state->textures.push_back(texture);

                _state->textureIds[texture] = index;
                textureId = index;
            } else {
                textureId = _state->textureIds[texture];
            }

            auto suffix = keyword.substr(4, 2);
            if(suffix == "Kd") {
                mat->diffuseTexture = textureId;
            } else if(suffix == "Ka") {
                mat->ambientTexture = textureId;
            } else if(suffix == "Ks") {
                mat->specularTexture = textureId;
            } else {
                Warning() << "Trade::ObjImporter::parseMaterialLibrary(): unsupported texture type:" << suffix;
            }

        /* Ignore unsupported keywords, error out on unknown keywords */
        } else {
            Warning() << "Trade::ObjImporter::parseMaterialLibrary(): unknown keyword:" << keyword;
        }

        /* Ignore the rest of the line */
        pos = skipWhitespaces(ignoreLine(pos));
    }
}

UnsignedInt ObjImporter::doObject3DCount() const { return _state->meshes.size() + _state->meshlessObjects.size(); }

Int ObjImporter::doObject3DForName(const std::string& name) {
    auto result = _state->meshlessObjectIds.find(name);
    if(result != _state->meshlessObjectIds.end()) {
        return result->second;
    }

    result = _state->meshIds.find(name);
    if(result != _state->meshIds.end()) {
        return result->second;
    }

    return -1;
}

std::string ObjImporter::doObject3DName(UnsignedInt id) {
    const size_t lastMesh = _state->meshes.size() - 1;
    if(id > lastMesh) {
        return _state->meshlessObjects[id - lastMesh];
    }
    return _state->meshes[id]->name();
}

std::unique_ptr<ObjectData3D> ObjImporter::doObject3D(UnsignedInt id) {
    const size_t lastMesh = _state->meshes.size() - 1;
    if(id > lastMesh) {
        return std::unique_ptr<ObjectData3D>{new ObjectData3D{{}, {}, &_state->meshlessObjects[id - lastMesh]}};
    }
    const ObjMesh& mesh = *_state->meshes[id];
    return std::unique_ptr<ObjectData3D>{
        new MeshObjectData3D{{}, {}, id, mesh.data.materialId, _state->meshes[id].get()}};
}

UnsignedInt ObjImporter::doMesh3DCount() const { return _state->meshes.size(); }

Int ObjImporter::doMesh3DForName(const std::string& name) {
    return _state->meshIds[name];
}

std::string ObjImporter::doMesh3DName(UnsignedInt id) {
    return _state->meshes[id]->name();
}

std::optional<MeshData3D> ObjImporter::doMesh3D(UnsignedInt id) {
    const ObjMesh& mesh = *_state->meshes[id];

    const Int primitiveSize = (mesh.primitive == MeshPrimitive::Triangles)
        ? 3 : ((mesh.primitive == MeshPrimitive::Lines) ? 2 : 1);

    std::vector<UnsignedInt> positionIndices;
    std::vector<UnsignedInt> normalIndices;
    std::vector<UnsignedInt> textureCoordinateIndices;

    positionIndices.reserve(mesh.minPrimitives*primitiveSize);
    if(primitiveSize >= 2) {
        /* Only need to allocate texCoords for lines and faces */
        textureCoordinateIndices.reserve(mesh.minPrimitives*primitiveSize);
        if(primitiveSize == 3) {
            /* Only need to allocate normals for faces */
            normalIndices.reserve(mesh.minPrimitives*primitiveSize);
        }
    }

    // TODO set to true on first non (-1) encounter
    bool hasNormals = false;
    bool hasTexCoords = false;

    for(auto section : mesh.sections) {
        auto pos = skipWhitespaces(section);

        switch(mesh.primitive) {
            case MeshPrimitive::Triangles:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'f' && pos[1] == ' ', "Unexpected primitive keyword for Triangles", {});
                    pos = pos.suffix(2);

                    for(Int i = 0; i < 3; ++i) {
                        std::array<Int, 3> vertex;
                        std::tie(vertex, pos) = parseVertex(pos);
                        positionIndices.push_back(vertex[0]);
                        textureCoordinateIndices.push_back(vertex[1]);
                        normalIndices.push_back(vertex[2]);

                        hasTexCoords = hasTexCoords || (vertex[1] != 0);
                        hasNormals = hasNormals || (vertex[2] != 0);

                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            case MeshPrimitive::Lines:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'l' && pos[1] == ' ', "Unexpected primitive keyword for Lines", {});
                    pos = pos.suffix(2);

                    while(!atEndOfLine(pos)) {
                        std::array<Int, 2> line;
                        std::tie(line, pos) = parseLine(pos);
                        positionIndices.push_back(line[0]);
                        textureCoordinateIndices.push_back(line[1]);

                        hasTexCoords = hasTexCoords || (line[1] != 0);

                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            case MeshPrimitive::Points:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'p' && pos[1] == ' ', "Unexpected primitive keyword for Points", {});
                    pos = pos.suffix(2);

                    ArrayView<const char> word;
                    while(!atEndOfLine(pos)) {
                        std::tie(word, pos) = nextWord(pos);
                        positionIndices.push_back(strToInt(word));
                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            default:
                CORRADE_ASSERT_UNREACHABLE();
        }
    }

    /* Merge index arrays, if there aren't just the positions */
    std::vector<UnsignedInt> indices;

    std::vector<std::vector<Vector3>> positionLayers;
    std::vector<std::vector<Vector3>> normalLayers;
    std::vector<std::vector<Vector2>> texCoordLayers;

    std::vector<std::reference_wrapper<std::vector<UnsignedInt>>> arrays;
    arrays.reserve(3);
    arrays.emplace_back(positionIndices);
    if(hasNormals) arrays.emplace_back(normalIndices);
    if(hasTexCoords) arrays.emplace_back(textureCoordinateIndices);
    indices = MeshTools::combineIndexArrays(arrays);

    /* Reindex data arrays */
    positionLayers.push_back(reindex(positionIndices, _state->positions));
    if(hasNormals) normalLayers.push_back(reindex(normalIndices, _state->normals));
    if(hasTexCoords) texCoordLayers.push_back(reindex(textureCoordinateIndices, _state->texCoords));

    return MeshData3D(mesh.primitive, std::move(indices), std::move(positionLayers),
            std::move(normalLayers), std::move(texCoordLayers), {}, &mesh);
}

UnsignedInt ObjImporter::doMaterialCount() const { return _state->materials.size(); }

std::unique_ptr<AbstractMaterialData> ObjImporter::doMaterial(const UnsignedInt id) {
    ObjMaterial& objMat = _state->materials[id];
    PhongMaterialData::Flags flags;

    if(objMat.ambientTexture != -1) {
        flags |= PhongMaterialData::Flag::AmbientTexture;
    }
    if(objMat.diffuseTexture != -1) {
        flags |= PhongMaterialData::Flag::DiffuseTexture;
    }
    if(objMat.specularTexture != -1) {
        flags |= PhongMaterialData::Flag::SpecularTexture;
    }

    PhongMaterialData* mat = new PhongMaterialData{
            flags,
            objMat.specularity};

    if(objMat.ambientTexture == -1) {
        mat->ambientColor() = objMat.ambient;
    } else {
        mat->ambientTexture() = objMat.ambientTexture;
    }

    if(objMat.diffuseTexture == -1) {
        mat->diffuseColor() = objMat.diffuse;
    } else {
        mat->diffuseTexture() = objMat.diffuseTexture;
    }

    if(objMat.specularTexture == -1) {
        mat->specularColor() = objMat.specular;
    } else {
        mat->specularTexture() = objMat.specularTexture;
    }

    return std::unique_ptr<AbstractMaterialData>(mat);
}

UnsignedInt ObjImporter::doImage2DCount() const { return _state->textures.size(); }

std::optional<ImageData2D> ObjImporter::doImage2D(UnsignedInt id) {
    CORRADE_ASSERT(manager(), "Trade::ObjImporter::image2D(): the plugin must be instantiated with access to plugin manager in order to open image files", {});

    std::unique_ptr<AbstractImporter> imageImporter = manager()->loadAndInstantiate("TgaImporter"); // probably AnyImageImporter would be the way to go here...
    if(!imageImporter->openFile(_state->fileRoot + _state->textures[id])) {
        return std::nullopt;
    }

    return imageImporter->image2D(0);
}


}}
